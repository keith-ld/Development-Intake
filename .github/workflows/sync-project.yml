name: Sync Intake Form
on:
  issues:
    types: [opened]

jobs:
  sync_project:
    runs-on: ubuntu-latest
    steps:
      - name: Parse Issue Body
        uses: zentered/issue-forms-body-parser@v2.2.0
        id: parse
        with:
          body: ${{ github.event.issue.body }}

      - name: Add and Update Project
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}
          ISSUE_ID: ${{ github.event.issue.node_id }}
          # Safely handle the business value text from the parser
          VAL_BUSINESS_VALUE: ${{ fromJson(steps.parse.outputs.data).business_value.text }}
        run: |
          # 1. Get Project and Metadata
          # We use number 1 as specified in your project URL
          PROJECT_ID=$(gh project list --owner "keith-ld" --format json --jq '.projects[] | select(.number==1) | .id')
          FIELD_DATA=$(gh project field-list 1 --owner "keith-ld" --format json)
          
          # 2. ATOMIC ADD (The Fix)
          # This mutation adds the issue and returns the PVTI_ ID in the same response.
          # No searching or waiting required.
          RESPONSE=$(gh api graphql -f query='
            mutation($project: ID!, $issue: ID!) {
              addProjectV2ItemById(input: {projectId: $project, contentId: $issue}) {
                item { id }
              }
            }' -f project="$PROJECT_ID" -f issue="$ISSUE_ID")
          
          ITEM_ID=$(echo "$RESPONSE" | jq -r '.data.addProjectV2ItemById.item.id')
          
          if [ "$ITEM_ID" == "null" ] || [ -z "$ITEM_ID" ]; then
            echo "Error: Atomic add failed. Response: $RESPONSE"
            exit 1
          fi
          echo "Successfully generated Project Item ID: $ITEM_ID"

          # 3. Get Field IDs
          W_FIELD_ID=$(echo "$FIELD_DATA" | jq -r '.fields[] | select(.name=="Workflow Stage") | .id')
          B_FIELD_ID=$(echo "$FIELD_DATA" | jq -r '.fields[] | select(.name=="Business Value") | .id')
          
          # 4. Get Option IDs
          W_OPTION_ID=$(echo "$FIELD_DATA" | jq -r --arg f_id "$W_FIELD_ID" '.fields[] | select(.id==$f_id) | .options[] | select(.name=="New Request") | .id')
          
          # Default logic for Business Value
          BV_TEXT="${VAL_BUSINESS_VALUE:-Medium}"
          [[ "$BV_TEXT" == "_No response_" ]] && BV_TEXT="Medium"
          B_OPTION_ID=$(echo "$FIELD_DATA" | jq -r --arg f_id "$B_FIELD_ID" --arg opt "$BV_TEXT" '.fields[] | select(.id==$f_id) | .options[] | select(.name==$opt) | .id')

          # 5. Execute Updates via GraphQL
          # This is the "Industry Standard" way that avoids the CLI's internal node resolution errors.
          gh api graphql -f query='
            mutation($p:ID!,$i:ID!,$f:ID!,$o:String!){
              updateProjectV2ItemFieldValue(input:{projectId:$p,itemId:$i,fieldId:$f,value:{singleSelectOptionId:$o}}){
                projectV2Item{id}
              }
            }' -f p="$PROJECT_ID" -f i="$ITEM_ID" -f f="$W_FIELD_ID" -f o="$W_OPTION_ID"

          gh api graphql -f query='
            mutation($p:ID!,$i:ID!,$f:ID!,$o:String!){
              updateProjectV2ItemFieldValue(input:{projectId:$p,itemId:$i,fieldId:$f,value:{singleSelectOptionId:$o}}){
                projectV2Item{id}
              }
            }' -f p="$PROJECT_ID" -f i="$ITEM_ID" -f f="$B_FIELD_ID" -f o="$B_OPTION_ID"
